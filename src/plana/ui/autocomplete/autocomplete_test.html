<!DOCTYPE html>
<html class="no-js">
<!--
Copyright 2014 Plan-A Software Ltd. All Rights Reserved.

Use of this source code is governed by the Apache License, Version 2.0.
-->
<!--
  @author kiran@plan-a-software.co.uk (Kiran Lakhotia)
-->

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Typeahead Test</title>
  <meta name="description" content="Unit tests for the autocomplete component">
  <meta name="viewport" content="width=device-width">
  <link rel="stylesheet" href="../../../css/autocomplete.css">
</head>

<body>

  <div id="container">
  </div>

  <!-- set the path to goog base -->
  <script src="../../vendor/goog/base.js"></script>
  <script type="text/javascript">
  goog.require('goog.Uri');
  goog.require('goog.dom');
  goog.require('goog.events.KeyCodes');
  goog.require('goog.net.WrapperXmlHttpFactory');
  goog.require('goog.testing.AsyncTestCase');
  goog.require('goog.testing.events');
  goog.require('goog.testing.jsunit');
  goog.require('goog.testing.net.XhrIo');
  goog.require('goog.ui.ac.InputHandler');
  goog.require('goog.ui.ac.Renderer');
  goog.require('goog.ui.ac.RemoteArrayMatcher');
  goog.require('goog.ui.ac.CachingMatcher');
  goog.require('goog.ui.Component');
  </script>

  <script type="text/javascript" src="remoteobjectmatcher.js"></script>
  <script type="text/javascript" src="autocompleterenderer.js"></script>
  <script type="text/javascript" src="cachingobjectmatcher.js"></script>
  <script type="text/javascript" src="inputhandler.js"></script>
  <script type="text/javascript" src="autocomplete.js"></script>

  <script type="text/javascript">
  var mockServerObjects = [{
    id: 1,
    caption: 'hello'
  }, {
    id: 2,
    caption: 'world'
  }];
  var mockServerStrings = [
    'coding',
    'on',
    'keep',
    'calm',
    'and',
    'carry'
  ];

  function MockXmlHttp() {
    /**
     * The headers for this XmlHttpRequest.
     * @type {!Object.<string>}
     */
    this.headers = {};

    /**
     * The request data string
     * @type {string}
     */
    this.content;
  };

  var lastUri;

  MockXmlHttp.prototype.readyState = goog.net.XmlHttp.ReadyState.UNINITIALIZED;

  MockXmlHttp.prototype.status = 200;

  MockXmlHttp.syncSend = true;

  MockXmlHttp.prototype.send = function(opt_data) {
    this.content = opt_data;
    this.readyState = goog.net.XmlHttp.ReadyState.UNINITIALIZED;

    lastMockXmlHttp.responseText = this.getResponseJson();

    if (MockXmlHttp.syncSend) {
      this.complete();
    }

  };

  var sendDelay = 0;
  var timerId = null;
  MockXmlHttp.prototype.complete = function() {
    this.readyState = goog.net.XmlHttp.ReadyState.LOADING;
    this.onreadystatechange();

    this.readyState = goog.net.XmlHttp.ReadyState.LOADED;
    this.onreadystatechange();

    this.readyState = goog.net.XmlHttp.ReadyState.INTERACTIVE;
    this.onreadystatechange();

    if (timerId != null) {
      window.clearTimeout(timerId);
    }
    var self = this;
    timerId = window.setTimeout(function() {
      self.readyState = goog.net.XmlHttp.ReadyState.COMPLETE;
      self.onreadystatechange();
      self = null;
      timerId = null;
    }, sendDelay);
  };


  MockXmlHttp.prototype.open = function(verb, uri, async) {
    lastUri = uri;
  };

  MockXmlHttp.prototype.abort = function() {};

  MockXmlHttp.prototype.setRequestHeader = function(key, value) {
    this.headers[key] = value;
  };

  MockXmlHttp.prototype.getResponseJson = function(opt_xssiPrefix) {
    var uri = new goog.Uri(lastUri);
    var query = uri.getQueryData();
    var filterStrings = query.get('token').split(',');
    var matches = [];
    for (var i = 0, str; str = filterStrings[i]; ++i) {
      for (var o = 0, obj; obj = mockServerObjects[o]; ++o) {
        if (goog.string.contains(obj.caption, str) ||
          goog.string.caseInsensitiveCompare(obj.caption, str) == 0) {
          matches.push(obj);
        }
      }
      for (var s = 0, sobj; sobj = mockServerStrings[s]; ++s) {
        if (goog.string.contains(sobj, str) ||
          goog.string.caseInsensitiveCompare(sobj, str) == 0) {
          matches.push(sobj);
        }
      }
    }
    return goog.json.serialize(matches);
  };

  var lastMockXmlHttp;
  goog.net.XmlHttp.setGlobalFactory(new goog.net.WrapperXmlHttpFactory(
    function() {
      lastMockXmlHttp = new MockXmlHttp();
      return lastMockXmlHttp;
    },
    function() {
      return {};
    }));
  </script>

  <script type="text/javascript">
  var testCase = goog.testing.AsyncTestCase.createAndInstall('autocomplete');
  var asyncTimer = null;
  var autocomplete = null;
  var loadingImg = goog.dom.createDom('img', {
    'src': '/alternative/img/ajax-loader.gif'
  });

  function setUp() {
    sendDelay = 0;
    autocomplete = new plana.ui.ac.AutoComplete(new goog.Uri('fuchs'));
    autocomplete.setLoadingContent(loadingImg);
    autocomplete.render(document.getElementById('container'));
  }

  function tearDown() {
    if (timerId != null) {
      window.clearTimeout(timerId);
      timerId = null;
    }
    if (asyncTimer != null) {
      window.clearTimeout(asyncTimer);
      asyncTimer = null;
    }
    if (autocomplete != null)
      autocomplete.dispose();
    autocomplete = null;
  }

  function waitForRequest(done) {
    asyncTimer = null;
    if (lastMockXmlHttp &&
      lastMockXmlHttp.readyState == goog.net.XmlHttp.ReadyState.COMPLETE) {
      var parent = goog.dom.getParentElement(autocomplete.fetchingMatchesDom_);
      if (parent == null) {
        testCase.continueTesting();
        done();
        return;
      }
    }
    asyncTimer = window.setTimeout(function() {
      waitForRequest(done);
    }, 100);
  }

  function getInput() {
    return autocomplete.getRenderer().getInput(autocomplete, goog.dom.getDomHelper());
  }

  function setToken(token) {
    autocomplete.autoComplete.setToken(token);
    var input = getInput();
    input.value = token;
  }

  function testNotificationRows() {
    var parent;
    var checkResponse = function() {
      //assert no match found message is showing
      parent = goog.dom.getParentElement(autocomplete.noMatchesDom_);
      assertTrue('no match hidden', parent != null && autocomplete.autoComplete.getRenderer().isVisible());

      var checkNoMatch = function() {
        //assert no match found message is hidden
        parent = goog.dom.getParentElement(autocomplete.noMatchesDom_);
        assertNull('no match showing', parent);
      };

      autocomplete.autoComplete.setToken('hel');
      testCase.waitForAsync('waiting for server');
      waitForRequest(checkNoMatch);
    };
    sendDelay = 500;
    autocomplete.autoComplete.setToken('x');
    testCase.waitForAsync('waiting for server');
    waitForRequest(checkResponse);
    //assert that the loading div is showing
    parent = goog.dom.getParentElement(autocomplete.fetchingMatchesDom_);
    assertNotNull('loading not shwowing', parent);
  }

  function testFocus() {
    autocomplete.focus();
    assertEquals('input is not focused',
      getInput(),
      document.activeElement);
  }

  function testSetModel() {
    var cbList = [];
    var sendNonMatchingKey = function() {
      var onKeyProcessed = function() {
        //hit enter
        goog.testing.events.fireKeySequence(getInput(), goog.events.KeyCodes.ENTER);
        //assert model is set to null
        assertNull('model incorrectly set to non null', autocomplete.getModel());
        var nextCb = cbList.shift();
        if (nextCb)
          nextCb();
      };
      autocomplete.autoComplete.setToken('x');
      testCase.waitForAsync('waiting for server');
      waitForRequest(onKeyProcessed);
    };
    var sendMatchingStrKey = function() {
      var onKeyProcessed = function() {
        //hit enter
        goog.testing.events.fireKeySequence(getInput(), goog.events.KeyCodes.ENTER);
        //assert model is set to null
        assertEquals('model should be coding', 'coding', autocomplete.getModel());
        var nextCb = cbList.shift();
        if (nextCb)
          nextCb();
      };
      autocomplete.autoComplete.setToken('coding');
      testCase.waitForAsync('waiting for server');
      waitForRequest(onKeyProcessed);
    };
    var sendMatchingObjKey = function() {
      var onKeyProcessed = function() {
        //hit enter
        goog.testing.events.fireKeySequence(getInput(), goog.events.KeyCodes.ENTER);
        //assert model is set to null
        var model = autocomplete.getModel();
        assertEquals('model should be hello', 'hello', model.caption);
        assertEquals('model id should be 1', 1, model.id);
        var nextCb = cbList.shift();
        if (nextCb)
          nextCb();
      };
      autocomplete.autoComplete.setToken('hello');
      testCase.waitForAsync('waiting for server');
      waitForRequest(onKeyProcessed);
    };

    //send non matching key and expect model to be null
    //send matching key and expect model to be string
    //send matching key and expect model to be object
    //send non matching key and expect model to be null
    cbList = [sendMatchingStrKey, sendMatchingObjKey, sendNonMatchingKey];
    sendNonMatchingKey();
  }

  function testEmptyToken() {
    //the empty token should hide the list and not show any
    //loading or no match messages
    var parent;
    var onKeyProcessed = function() {
      //hit enter
      goog.testing.events.fireKeySequence(getInput(), goog.events.KeyCodes.ENTER);

      //assert no match is showing
      parent = goog.dom.getParentElement(autocomplete.noMatchesDom_);
      assertTrue('no match hidden', parent != null && autocomplete.autoComplete.getRenderer().isVisible());

      //delete x
      //goog.testing.events.fireKeySequence(getInput(), goog.events.KeyCodes.BACKSPACE);
      setToken('xx');
      //make sure we fire server request
      autocomplete.cachingMatcher.throttledTriggerBaseMatch_.doAction_();
      //now quickly set the input to an empty string...this should mean
      //when the server request returns, the no-match will be hidden
      setToken('');

      var onDelete = function() {
        parent = goog.dom.getParentElement(autocomplete.noMatchesDom_);
        assertTrue('no match showing', parent == null && !autocomplete.autoComplete.getRenderer().isVisible());
      };

      testCase.waitForAsync('waiting for server');
      waitForRequest(onDelete);
    };
    setToken('x');
    testCase.waitForAsync('waiting for server');
    waitForRequest(onKeyProcessed);
  }
  </script>
</body>

</html>